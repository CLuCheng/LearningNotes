# ARM嵌入式Linux系统开发详解

## ARM处理器

### 微处理器和微控制器

微处理器可以根据应用领域分为：

- 通用微处理器：用于高性能计算

- 嵌入式微处理器：针对某种特定应用的高能力计算

- 微控制器：控制某种设备

### ARM处理器介绍

ARM： Advanced RISC Machines，高性能RISC（精简指令集）机器。

ARM的功能特点

- 芯片体积小，功耗低，制造成本低，性能优异
- 支持Thumb（16位）和ARM（32位）两种指令集，8位和16位设备兼容性好
- 由于采用RISC架构，在内部大量使用寄存器，执行指令速度快
- 大部分指令是操作寄存器，很少会访问外部存储
- 采用多级流水线结构处理速度快
- 支持采用多种寻址方式，数据存取方式灵活
- 指令长度固定，便于编译器操作以及执行指令

### ARM指令集

ARM指令集按照功能可以分为算术运算指令，逻辑运算指令，分支指令，软件中断指令和程序数据装载指令等

### ARM的结构

ARM体系结构命名方法：

| ARM  | v      | x1         | x2           |
| ---- | ------ | ---------- | ------------ |
| 固定 | 版本号 | 支持指令集 | 不支持指令集 |

ARM体系结构指令集列表

| 指令集缩写 | 含义                 |
| ---------- | -------------------- |
| T          | Thumb指令集          |
| M          | 长乘法指令集         |
| E          | 增强DSP指令集        |
| J          | 支持Java加速器       |
| SIMD       | 多媒体功能扩展指令集 |

处理器系列划分

| ARM  | xyz                                         | m          |
| ---- | ------------------------------------------- | ---------- |
| 固定 | x 处理器系列；y 是否有存储管理；z Cache类型 | 支持的功能 |

ARM处理器的工作模式

| 工作模式名称        | 含义                         |
| ------------------- | ---------------------------- |
| 用户模式usr         | 正常的程序执行状态           |
| 快速终端模式fiq     | 高速数据传输和通道处理       |
| 外部中断模式irq     | 通用中断处理                 |
| 管理模式svc         | 操作系统使用                 |
| 数据访问终止模式abt | 虚拟内存和存储保护使用       |
| 系统模式sys         | 运行具有特权的操作系统任务   |
| 未定义模式und       | 执行了不存在的指令进入该模式 |

应用程序运行在用户模式下，一些被保护的资源是不能被用户访问，另外6种模式称为特权模式，除系统模式外，其他5中模式用来处理系统的软硬件异常，被称为异常模式

## Linux应用程序编程基础

### 堆和栈

应用程序主要分段解释

| text     | 代码区静态数据   |
| -------- | ---------------- |
| data     | 全局初始化数据区 |
| bss      | 未初始化数据区   |
| dec      | 十进制总和       |
| hex      | 十六进制总和     |
| filename | 文件名           |

栈是一个有编译器分配释放的区域，用来存放函数的参数、局部变量等

栈的管理方式是FILO，先进后出

堆位于bss段和栈之间，用来动态分配内存

`malloc()`分配内存，`free()`释放`malloc()`分配的内存

`calloc()`用来分配一块新内存，`realloc()`用来改变一块已经分配的内存大小，在C标准库stdlib.h中定义

`malloc()`和`calloc()`区别在于，前者分配内存空间后不会初始化

> free() 可以安全释放calloc()函数分配的内存

### ANSI C文件管理

ANSI文件操作提供了一个重要的结构——文件指针FILE。文件的打开、读写和关闭，以及其他访问都要通过文件指针完成

2中存储方式：

- 文本操作：每个字节存储一个ASCII字符，文本文件存储量大，便于对字符操作，速度慢

- 二进制：按照内存中存储形式存放，存储量小，速度快

Linux为每个进程定义了stdin标准输入，stdout标准输出和stderr标准错误三个文件流，也称为I/O数据流

标准文件I/O三种缓冲

- 全缓冲
- 行缓冲
- 不带缓冲

```c
void setbuf(FILE *fp, char *buf);

int setvbuf(FILE *fp, char *buf, int mode, size_t size);
```

关闭缓冲传NULL

mode参数：

- _IOFBF：全缓冲

- _IOLBF：行缓冲

- _IONBF：不带缓冲

> setvbuf，buf 为NULL，但mode任然设置全缓冲和行缓冲的时候会自动设置一个适当长度的缓冲

打开文件`fopen()`，关闭`fclose()`

读写文件3种类型：

- 每次一个字符：getc() fgetc() getchar()	putc() fputc() putchar()
- 每次一行，换行符\n标志一行结束:  fgets() gets()	fputs()  puts() 
- 成块数据: fread()	fwrite()

文件流定位：fseek() ftell() rewind()

### POSIX 文件I/O编程

POSIX文件操作的函数基本上和计算机设备驱动的底层操作是一一对应的，使用过open()函数打开一个文件，使用create()函数创建一个新文件，close()关闭文件，read()读，write()写，lseek()定位，fcntl()获取或改变已打开文件的属性

## 开发多进程/线程程序

### 多进程开发

操作系统通过PCB（进程控制块）的数据结构管理一个进程

进程是操作系统分配资源的最小单位

getenv()和putenv()函数读取或设定一个环境变量

Linux通过fork()系统调用创建一个进程

waitpid()等待另一个进程结束

| pid取值 | 解释                                   |
| ------- | -------------------------------------- |
| <-1     | 等待pid绝对值的子进程                  |
| -1      | 等待任何子进程                         |
| 0       | 等待任何其标识等于调用进程组标识的进程 |
| >0      | 等待等于pid的子进程                    |



exit()退出当前进程，并尽可能释放当前进程占用的资源

_exit()退出但不释放资源

atexit()为退出指定调用代码，无参

on_exit()为退出指定调用代码，可以设定参数

> atexit()可以设置多个，按栈的方式，先注册的后调用

Linux常见的进程间通信方法：管道、FIFO、消息队列、信号量、共享内存

- 管道：半双工，只能在一个方向上传数据；只能在有共同父进程的进程间使用。pipe()函数创建一个管道。参数filedes返回2个文件描述符，filedes[0]为读端，filedes[1]为写端，创建成功返回0。
- 共享内存：在内存中开辟一块空间，供不同进程访问。
  - shmget() 创建共享内存
  - shmat() 获得一个共享内存ID对应的内存起始地址
  - shmdt() 从程序中分离一块共享内存

ipcs查看目前的共享资源情况

ipcrm释放指定的共享内存

### 多线程开发

线程是操作系统调度的最小单位

Linux系统开发多线程程序大多使用pthread库

pthread_create() 创建

线程的退出：线程本身代码运行结束后会自动退出；线程代码调用return会导致退出；通过其他线程退出

phread_cancel() 取消一个线程的执行

phtread_join() 等待一个线程结束

## 网络通信应用

### 网络通信基础

TCP/IP协议族：应用层，传输层，网络层，物理层

OSI参考模型：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层

### Socket通信基本概念

Socket是网络上的通信端点，封装了通信的细节

#### 创建Socket

对于应用程序员，socket对象就是一个文件句柄，通常使用socket()函数创建对象

#### 面向连接的socket通信实现

服务端工作流程：

- 使用socke()t函数创建socket
- 通过bind()函数把创建的socket句柄绑定到指定TCP端口中
- 调用listen()函数使socket处于监听状态，并且设置监听队列的大小
- 当客户端发送连接请求后，调用accept()函数接受客户端请求，与客户端建立连接
- 与客户端发送或接收数据
- 通信完毕，调用close()函数关闭连接

客户端工作流程

- 使用socket()函数创建socket
- 调用connect()函数向服务端socket发起连接
- 连接建立后，进行数据读写
- 数据传输完毕后，使用close()函数关闭socket

#### 无连接的socket通信

服务端在绑定socket后，即可发送和接收数据

客户端创建socket后，可以直接发送或读取数据

发送sendto函数，接收recvfrom函数

### Socket高级应用

Socket超时处理：getsockopt()，setsockopt() 设置套接字和得到套接字参数

Socket库提供了两个函数select和poll用来等待一组套接字句柄的读写操作。

- 使用select机制处理多连接

- 使用poll机制处理多连接

> select和poll可以解决一个进程需要同时处理多个网络连接的问题，但仍然需要等待，可以利用多线程防止阻塞

## 串口通信编程

Linux系统中串口设备被当做一个字符设备处理。在/dev目录下有若干个ttySx（x代表0开始的正数）设备文件。ttyS0对应Windows的COM1

串口的操作方式与文件类似，可以使用相同方法打开关闭读写以及使用slect()监听串口，但不能使用fseek()之类的文件定位函数

Linux使用termios结构来存储串口参数，在termios.h头文件定义，且提供了一组设置函数

AT指令集是GSM网络中网络设备之间发送控制信息的标准指令集

AT指令使用"AT+命令模式"的格式

## ARM体系结构及开发实例

### ARM体系结构介绍

ARM处理器是从商业角度出发设计的RISC微处理器

采用的结构特征：

- Load/Store体系结构

- 固定的32位指令

- 3地址指令格式

放弃的特征：

- 寄存器窗口
- 延迟转移
- 所有指令单周期执行

### 编程模型

ARM9微处理器支持3种数据类型，字节（8位），半字（16位），字（32位）

ARM处理器有31个通用寄存器和6个状态寄存器。通用寄存器R0-R14，程序计数器PC，以及特定2个状态寄存器在任何模式下都可以访问

ARM体系结构中，提供了5中异常处理模式

- FIQ（Fast Interrupt Request）模式：数据传输和通道处理
- IRQ（Interrupt Request）模式
- ABORT（中止模式）：访问存储器失败的时候会产生终止异常
- Software Interrupt（软件中断模式）：请求执行特定的管理功能
- Undefined Instruction（未定义指令模式）：遇到不能处理的指令时会产生

ARM9微处理器提供了内存控制器，提供了虚拟地址到物理地址的映射、存储器访问权限控制，以及高速缓存支持

### 常见的接口和控制器

GPIO接口：通用I/O端口。一个GPIO端口至少需要2个寄存器，一个控制，一个存放数据

中断控制器：ARM9支持2中类型中断：正常请求中断和快速中断请求

RTC控制器：实时时钟（Real Time Clock），当系统断电，RTC可以使用备份电池操作

看门狗定时器：监测程序运行状态



## 深入BIOS

常见BootLoader：U-Boot 是一个规模庞大的开源BootLoader软件。U-Boot支持处理器和操作系统很多，但是对PowerPC系列处理器和Linux操作系统支持最好。

U-Boot启动分为stage1和stage2两个阶段。stage1使用汇编，与CPU体系紧密相关，如处理器初始化和设备初始化代码等。stage2使用C语言，包括初始化Flash器件、检测系统内存映射、初始化网络设备、进入命令循环，接收用户从串口发送的命令然后进行相应的处理。

### 移植U-Boot到开发板

#### U-Boot移植的一般步骤

- 检测U-Boot工程是否支持目标平台
- 分析目标平台类似的工程
- 分析目标平台代码
- 建立新的开发板平台目录
- 对照手册修改平台差异部分代码
- 调试新代码

#### 移植U-Boot到目标开发板

- 建立新目标板工程目录
- 向配置文件加入新开发板配置
- 预编译新开发板的代码
- 修改目标板配置
- 编译新的配置并且下载执行

