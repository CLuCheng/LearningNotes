# [学习笔记]菜鸟教程Swift易忘知识点总结（四）

---
[CSDN链接](https://blog.csdn.net/baidu_32237719/article/details/83014708)
## 类

### 类和结构体对比
Swift 中类和结构体有很多共同点。共同处在于：
- 定义属性用于存储值
- 定义方法用于提供功能
- 定义附属脚本用于访问值
- 定义构造器用于生成初始化值
- 通过扩展以增加默认实现的功能
- 符合协议以对某类提供标准功能

与结构体相比，类还有如下的附加功能：
- 继承允许一个类继承另一个类的特征
- 类型转换允许在运行时检查和解释一个类实例的类型
- 解构器允许一个类实例释放任何其所被分配的资源
- 引用计数允许对一个类的多次引用

### 语法

```swift
	class classname {
	   Definition 1
	   Definition 2
	   ……
	   Definition N
	}
```

### 作为引用类型访问类属性

类的属性可以通过 . 来访问。格式为：实例化类名.属性名

## 属性

- Swift 属性将值跟特定的类、结构或枚举关联。
- 属性可分为存储属性和计算属性

存储属性| 	计算属性
-------- | -----
存储常量或变量作为实例的一部分| 	计算（而不是存储）一个值
用于类和结构体| 	用于类、结构体和枚举

- 存储属性和计算属性通常用于特定类型的实例。
- 属性也可以直接用于类型本身，这种属性称为类型属性。
- 另外，还可以定义属性观察器来监控属性值的变化，以此来触发一个自定义的操作。属性观察器可以添加到自己写的存储属性上，也可以添加到从父类继承的属性上。

### 存储属性

一个存储属性就是存储在特定类或结构体的实例里的一个常量或变量。
存储属性可以是变量存储属性（var定义），也可以是常量存储属性（let定义）。
- 可以在定义存储属性的时候指定默认值
- 可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值

### 延迟存储属性
- 延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性。
- 在属性声明前使用 lazy 来标示一个延迟存储属性。
>注意：必须将延迟存储属性声明成变量（使用var关键字），因为属性的值在实例构造完成之前可能无法得到。而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性。

延迟存储属性一般用于：
- 延迟对象的创建。
- 当属性的值依赖于其他未知类


### 计算属性
- 除存储属性外，类、结构体和枚举可以定义计算属性，计算属性不直接存储值，而是提供一个 getter 来获取值，一个可选的 setter 来间接设置其他属性或变量的值。

- 如果计算属性的 setter 没有定义表示新值的参数名，则可以使用默认名称 newValue。

### 只读计算属性
- 只有 getter 没有 setter 的计算属性就是只读计算属性。
- 只读计算属性总是返回一个值，可以通过点(.)运算符访问，但不能设置新的值。

> 注意：必须使用var关键字定义计算属性，包括只读计算属性，因为它们的值不是固定的。let关键字只用来声明常量属性，表示初始化后再也无法修改的值。

### 属性观察器
属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，甚至新的值和现在的值相同的时候也不例外。
可以为**除了延迟存储属性之外**的其他存储属性添加属性观察器，也可以通过重载属性的方式为继承的属性（包括存储属性和计算属性）添加属性观察器。
>注意：不需要为无法重载的计算属性添加属性观察器，因为可以通过 setter 直接监控和响应值的变化。

可以为属性添加如下的一个或全部观察器：
- willSet在设置新的值之前调用
- didSet在新的值被设置之后立即调用
- willSet和didSet观察器在属性初始化过程中不会被调用

```swift
	class Samplepgm {
	    var counter: Int = 0{
	        willSet(newValue){
	            print("计数器: \(newValue)")
	        }
	        didSet{
	            if counter > oldValue {
	                print("新增数 \(counter - oldValue)")
	            }
	        }
	    }
	}
	let NewCounter = Samplepgm()
	NewCounter.counter = 100
	NewCounter.counter = 800	
```

### 全局变量和局部变量
计算属性和属性观察器所描述的模式也可以用于全局变量和局部变量。
局部变量 | 	全局变量
-------- | -----
在函数、方法或闭包内部定义的变量。 | 	函数、方法、闭包或任何类型之外定义的变量。
用于存储和检索值。 | 	用于存储和检索值。
存储属性用于获取和设置值。 | 	存储属性用于获取和设置值。
也用于计算属性。	 | 也用于计算属性。

### 类型属性  
- 类型属性是作为类型定义的一部分写在类型最外层的花括号（{}）内。
- 使用关键字 static 来定义值类型的类型属性，关键字 class 来为类定义类型属性。

- 类似于实例的属性，类型属性的访问也是通过点运算符(.)来进行。
- 类型属性是通过类型本身来获取和设置，而不是通过实例。


## 方法


### 实例方法

在 Swift 语言中，实例方法是属于某个特定类、结构体或者枚举类型实例的方法。
- 实例方法提供以下方法：
	- 可以访问和修改实例属性
	- 提供与实例目的相关的功能

- 实例方法要写在它所属的类型的前后大括号({})之间。
- 实例方法能够隐式访问它所属类型的所有的其他实例方法和属性。
- 实例方法只能被它所属的类的某个特定实例调用。
- 实例方法不能脱离于现存的实例而被调用。

语法：


```swift
	func funcname(Parameters) -> returntype
	{
	    Statement1
	    Statement2
	    ……
	    Statement N
	    return parameters
	}
```

### 方法的局部参数名称和外部参数名称
- Swift 函数参数可以同时有一个局部名称（在函数体内部使用）和一个外部名称（在调用函数时使用）
- Swift 中的方法和 Objective-C 中的方法极其相似。像在 Objective-C 中一样，Swift 中方法的名称通常用一个介词指向方法的第一个参数，比如：with，for，by等等。
- Swift 默认仅给方法的第一个参数名称一个局部参数名称;默认同时给第二个和后续的参数名称为全局参数名称。


### self 属性
类型的每一个实例都有一个隐含属性叫做self，self 完全等同于该实例本身。


### 在实例方法中修改值类型
- Swift 语言中结构体和枚举是值类型。一般情况下，值类型的属性不能在它的实例方法中被修改。
- 但是，如果你确实需要在某个具体的方法中修改结构体或者枚举的属性，你可以选择变异(mutating)这个方法，然后方法就可以从方法内部改变它的属性；并且它做的任何改变在方法结束时还会保留在原始结构中。
- 方法还可以给它隐含的self属性赋值一个全新的实例，这个新实例在方法结束后将替换原来的实例。



### 类型方法
- 实例方法是被类型的某个实例调用的方法，你也可以定义类型本身调用的方法，这种方法就叫做类型方法。
- 声明结构体和枚举的类型方法，在方法的func关键字之前加上关键字static。类可能会用关键字class来允许子类重写父类的实现方法。
- 类型方法和实例方法一样用点号(.)语法调用。

## 下标脚本

- 下标脚本 可以定义在类（Class）、结构体（structure）和枚举（enumeration）这些目标中，可以认为是访问对象、集合或序列的快捷方式，不需要再调用实例的特定的赋值和访问方法。
- 举例来说，用下标脚本访问一个数组(Array)实例中的元素可以这样写 someArray[index] ，访问字典(Dictionary)实例中的元素可以这样写 someDictionary[key]。
- 对于同一个目标可以定义多个下标脚本，通过索引值类型的不同来进行重载，而且索引值的个数可以是多个。


### 下标脚本语法及应用
语法

- 下标脚本允许你通过在实例后面的方括号中传入一个或者多个的索引值来对实例进行访问和赋值。
- 语法类似于实例方法和计算型属性的混合。
- 与定义实例方法类似，定义下标脚本使用subscript关键字，显式声明入参（一个或多个）和返回类型。
- 与实例方法不同的是下标脚本可以设定为读写或只读。这种方式又有点像计算型属性的getter和setter：


```swift
	subscript(index: Int) -> Int {
	    get {
	        // 用于下标脚本值的声明
	    }
	    set(newValue) {
	        // 执行赋值操作
	    }
	}
```


### 下标脚本选项
- 下标脚本允许任意数量的入参索引，并且每个入参类型也没有限制。
- 下标脚本的返回值也可以是任何类型。
- 下标脚本可以使用变量参数和可变参数。
- 一个类或结构体可以根据自身需要提供多个下标脚本实现，在定义下标脚本时通过传入参数的类型进行区分，使用下标脚本时会自动匹配合适的下标脚本实现运行，这就是**下标脚本的重载**。