#设计模式

## 观察者模式


**定义:**
观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新


观察者模式提供了一种对象设计，让主题和观察者之间松耦合

对于观察者的一切，主题只知道观察者实现了某个接口

松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低

使用观察者模式时，可以从被观察者处push或pull数据

observable有多个观察者时，不可以依赖特定的通知顺序，observable实现采用的是继承，存在一些问题



## 装饰者模式

**定义：**

装饰者模式动态地将责任附加到对象上。若要扩展此功能，装饰者提供了比继承更有弹性的代替方案。

在程序设计中，应该允许行代码可以被扩展，而无需修改现有的代码

组合和委托可在允许时动态地加上新的行为

装饰者模式意味着一群装饰者类，这些类用来包装具体的组件

装饰者反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。

装饰者可以在被装饰者的行为前面或后面加上自己的行为，甚至将被装饰者行为整个取代掉，而达到特定的目的

可以用无数个装饰者包装一个组件

装饰者一般对组件的客户是透明的，除非客户程序依赖与组件的具体类型

装饰者会导致设计中出现许多小对象，过度使用，会让程序变的很复杂



## 工厂模式

分为：简单工厂模式，工厂模式和抽象工厂模式

简单工厂模式其实不是一种设计模式，反而比较像是一种编程习惯，但仍可以将客户程序从具体实现解耦

工厂方法用来处理对象的创建，并将这样的行为封装在子类，客户程序中关于超类的代码就和子类对象创建代码解耦类

所有工厂模式都是用来封装对象的创建，都通过减少应用程序和具体类之间的依赖促进松耦合

工厂模式方法通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的

工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象

**工厂方法模式**：定义了一个创建对象的接口，但由于子类决定要实例化的类是哪一个。工厂方法让类把实例化到子类。

依赖倒置原则：要依赖抽象，不要依赖具体的类

避免OO设计中违反依赖倒置原则的指导方针：

- 变量不可以持有具体的引用
- 不要让类派生自具体类
- 不要覆盖基类中以实现的方法

**抽象工厂模式**：提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确制定具体类

抽象工厂使用对象耦合：对象的创建被实现在工厂接口所暴露出来的方法中



## 单例模式

单例模式：确保一个类只有一个实例，并提供一个全局访问点

多线程下的单例模式：

- 如果`getInstance()`的性能对应用不是很关键，就什么也别做
- 使用“饿汉式”创建实例，而不用“懒汉式”实例化的做法
- 用“双重检查锁”，在`getInstance()`中减少使用同步

```java
public class Singleton {
	private volatile static Singleton uniqueInstance;
 
	private Singleton() {}
 
	public static Singleton getInstance() {
		if (uniqueInstance == null) {
			synchronized (Singleton.class) {
				if (uniqueInstance == null) {
					uniqueInstance = new Singleton();
				}
			}
		}
		return uniqueInstance;
	}
}

```

















































